handleData([{"name":"hello","code":"void Main() {\n\tConsole.WriteLine(\"Enter your name: \");\n\tvar {{veryBadVariableName_clickIt}} = Console.ReadLine();\n\tConsole.WriteLine(\"Hello, \" + {{veryBadVariableName_clickIt}});\n}","bugs":{"veryBadVariableName_clickIt":{"type":"naming","replace":"name","description":"Длинное и ужасное имя переменной!"}}},{"name":"GetThem","code":"List<Position> {{GetThem}}() {\n\tvar {{list1}} = new List<Position>();\n\tforeach (var cell in {{theBigList}})\n\t\tif (cell.IsEmpty)\n\t\t\t{{list1}}.Add(cell.Position);\n\treturn {{list1}};\n}","bugs":{"GetThem":{"type":"naming","replace":"GetEmptyPositions","description":"Не используйте местоимения в именах. Это совсем не добавляет понятности."},"list1":{"type":"naming","replace":"emptyPositions","description":"Имя должно отражать семантику, а не тип переменной. Имена вида s, list, array не дают полезной информации читателю."},"theBigList":{"type":"naming","replace":"allCells","description":"Имя должно отражать семантику, а не тип переменной. Имена вида s, list, array не дают полезной информации читателю."}}},{"name":"ViewsPerSecond","code":"double GetViewsPerSecond(IEnumerable<PageView> views, DateTime {{t}}) {\n\tvar {{total}} = {{86400}};\n\tvar viewsCount = views.Count(v => v.Timestamp.Date == {{t}});\n\treturn (double)viewsCount / {{total}};\n}","bugs":{"86400":{"type":"other","replace":"24 * 60 * 60","description":"Иногда, арифметические выражения понятнее, чем значение этого выражения.\nЗапись 24 * 60 * 60 проще проверить на корректность, чем 86400."},"t":{"type":"naming","replace":"date","description":"В именах стоит отражать существенные особенности. \nНапример, если переменная типа DateTime хранит только дату, можно назвать ее date."},"total":{"type":"naming","replace":"secondsInDay","description":"Имя переменной должно кратко, но емко отражать семантику."}}},{"name":"rstr","code":"var {{rstr}} = Console.ReadLine();\nvar {{f}} = false;\nfor(var {{indxInReadString}} = 0; {{indxInReadString}} < {{rstr}}.Length; {{indxInReadString}}++) {\n\tif ({{f}} || {{rstr}}[{{indxInReadString}}] != '\\\\')\n\t\tConsole.Write({{rstr}}[{{indxInReadString}}]);\n\t{{f}} = {{rstr}}[{{indxInReadString}}] == '\\\\';\n}","bugs":{"rstr":{"replace":"line","type":"naming","description":"Избегайте труднпрзнсимых имен и кодирования, понятного лишь вам."},"f":{"replace":"escaped","type":"naming","description":"Не называйте булевы переменные flag, f и подобными именами.\nУ каждого \"флага\" есть смысл, который и нужно отразить в имени."},"indxInReadString":{"replace":"charIndex","type":"naming","description":"Слишком длинные имена — тоже плохо. Сокращайте длину имен, но не в ущерб информативности."}}},{"name":"bigrams","code":"List<string> GetBigrams(IList<string> {{w}}) {\n\tvar {{сol_bigram}} = {{w}}.Count - 1;\n\tvar {{Bigrams}} = new string[{{сol_bigram}}];\n\tfor (var i = 0; i < {{сol_bigram}}; i++)\n\t\t{{Bigrams}}[i] = {{w}}[i] + \" \" + {{w}}[i + 1];\n\treturn {{Bigrams}}.Distinct().ToList();\n}","bugs":{"w":{"replace":"words","type":"naming","description":"Однобуквенные имена лучше использовать только в качестве локальных переменных с совсем малой областью видимости.\nОбщее правило — чем больше область видимости сущности, тем подробнее у неё должно быть имя.\nДлинное имя проще найти и сложнее с чем-то перепутать."},"сol_bigram":{"replace":"bigramsCount","type":"naming","description":"Не используйте русские слова в именах. Это запутает читателя.\nЧитая код, программисты ожидают видеть английские имена, \nпоэтому написанные транслитом русские слова могут быть восприняты неправильно.\nНапример, в данном случае col (количество) легко спутать с сокращением от слова column."},"Bigrams":{"type":"naming","replace":"bigrams","description":"В C# имена локальных переменных принято начинать с маленькой буквы.\nПридерживайтесь стандартного стиля именования для вашего языка программирования."}}},{"name":"arg","code":"static void Main(string[] args) {\n\tvar {{arg}} = args.Length > 0 ? args[0] : defaultFilename;\n\tDateTime {{time}} = new FileInfo({{arg}}).LastWriteTime;\n\tbool {{check}} = {{time}} > DateTime.Now - TimeSpan.FromSeconds(1);\n\tConvertFile({{arg}}, {{check}});\n\t{{show_content}}({{arg}});\n\tConsole.WriteLine({{time}});\n}","bugs":{"arg":{"replace":"inputFile","type":"naming","description":"Отражайте в имени то, что важно при дальнейшем использовании.\nВ данном случае то, что это имя входного файла важнее того, что оно получено из аргументов командной строки."},"time":{"replace":"lastWriteTime","type":"naming","description":"'lastWriteTime' сообщает больше полезной информации читателю, чем просто 'time'."},"check":{"replace":"recentlyModified","type":"naming","description":"Имя 'check' почти всегда можно улучшить. Сообщите в имени, что именно проверяется."},"show_content":{"replace":"ShowContent","type":"naming","description":"Придерживайтесь стандартного стиля именования для вашего языка программирования.\nВ C# принято использовать стиль CamelCase."}}},{"name":"CopyChars","code":"void CopyChars(char[] {{array1}}, char[] {{array2}}) {\n\t{{//copy arrays item by item.\n\t}}for(var i = 0; i < {{array1}}.Length; i++)\n\t\t{{array2}}[i] = {{array1}}[i];\n}","bugs":{"array1":{"replace":"source","type":"naming","description":"Имена с номерами на конце — это антипаттерн.\nВместо добавления номеров старайтесь отразить в именах суть различия."},"array2":{"replace":"destination","type":"naming","description":"Функцию с непонятными именами аргументов неудобно использовать."},"//copy":{"replace":"","type":"comments","description":"Нет смысла писать комментарии, повторяющие код."}}},{"name":"English","code":"enum {{QualityRender}} { High, Medium, Low };\n\nprivate string {{directoryInput}};\n\nprivate string outputDirectory;","bugs":{"QualityRender":{"type":"naming","replace":"RenderQuality","description":"Нарушение правильного порядка слов в составных именах — частая ошибка программистов \nсо слабым знанием английского.\nКачество рендера — это QualityOfRender или просто RenderQuality."},"directoryInput":{"type":"naming","replace":"inputDirectory","description":"directoryInput с английского — это ввод директории. Входная директория — это inputDirectory."}}},{"name":"ShareIfYouLike","code":"if (you.Like(this.Game)) {\n\tyou.Tweet(); \n\tyou.Post();\n\tyou.Instagram(); // why not?\n}\nelse {\n\tyou.{{HATE_AUTHOR()}};\n}\n","bugs":{"HATE_AUTHOR()":{"type":"naming","replace":"EmailAuthor(\"pe@kontur.ru\")","description":"Придерживайтесь стандартного стиля именования для вашего языка программирования.\nВ C# принято использовать стиль CamelCase."}}},{"name":"Chessboard","code":"enum {{ColorCell}} { Black, White };\n\nclass Chessboard {\n\tprivate {{ColorCell}}[,] {{array}};\n\tprivate int {{m_brdSz}};\n\t\n\tpublic Chessboard(int {{n}}) {\n\t\tthis.{{m_brdSz}} = {{n}};\n\t\tthis.{{array}} = new {{ColorCell}}[{{m_brdSz}},{{m_brdSz}}];\n\t\tfor(var {{a}} = 0; {{a}} < {{m_brdSz}}; {{a}}++)\n\t\t\tfor(var {{b}} = 0; {{b}} < {{m_brdSz}}; {{b}}++) {\n\t\t\t\tbool isBlack = ({{a}} + {{b}}) % 2 == 0;\n\t\t\t\t{{array}}[{{a}}, {{b}}] = isBlack ? {{ColorCell}}.Black : {{ColorCell}}.White;\n\t\t\t}\n\t}\n}\n","bugs":{"ColorCell":{"type":"naming","replace":"CellColor","description":"Нарушение правильного для английского языка порядка слов в составных именах — частая ошибка программистов \nсо слабым знанием английского.\nColorCell — это цветная клетка, а цвет клетки — CellColor.\nНе путайте — не вводите в замешательство читающих."},"n":{"type":"naming","replace":"size","description":"В данном контексте, n может обозначать как размер шахматной доски, так и количество фигур на доске или номер доски.\nИмя size устранит эту неоднозначность."},"m_brdSz":{"type":"naming","replace":"size","description":"Не используйте закодированные или труднопроизносимые имена. Вам их придется произносить или хотя бы мысленно проговаривать!"},"array":{"type":"naming","replace":"cellColors","description":"Имя должно отражать семантику, а не тип переменной. Имена вида s, list, array не дают полезной информации читателю."},"a":{"type":"naming","replace":"y","description":"Избегайте необходимости мысленного декодирования при чтении кода."},"b":{"type":"naming","replace":"x","description":"Используйте имена x, y для обозначения координат."}}},{"name":"Initialization","code":"public void {{Initialization}}(int boardSize) {\n\tlog.Info(\"Board initialization...\");\n\tthis.piecesCount = 0;\n\tthis.board = {{Board}}(boardSize, boardSize);\n\tlog.Info(\"Board initialization finished\");\n}","bugs":{"Initialization":{"type":"methods","replace":"InitializeBoard","description":"Методы — это действия, называйте их глаголами или глагольными фразами."},"Board":{"type":"methods","replace":"CreateBoard","description":"Методы — это действия, называйте их глаголами или глагольными фразами."}}},{"name":"GetSet","code":"void {{GetFactory}}() {\n\tvar user = Environment.UserName;\n\tthis.factory = {{FactoryCreator}}(user);\n}\n\nTimeSpan GetTimeout() {\n\treturn this.timeout;\n}\n\nvoid {{SetTimeout}}() {\n\tvar sectionName = systemName + \"/timeout\";\n\tthis.timeout = ReadSettings(sectionName).Timeout;\n}","bugs":{"GetFactory":{"type":"methods","replace":"InitFactory","description":"Методы GetXXX, CreateXXX, ReadXXX должны возвращать результат.\nvoid-методы, инициализирующие поля класса лучше так не называть."},"FactoryCreator":{"type":"methods","replace":"CreateFactory","description":"Методы — это действия, называйте их глаголами или глагольными фразами."},"SetTimeout":{"type":"methods","replace":"InitTimeoutFromSettings","description":"Методы SetXXX должны принимать устанавливаемое значение в качестве аргумента. \nМетоды без аргументов лучше так не называть."}}},{"name":"SplitMethod","code":"void Main(string[] args) {\n\tstring[] inputLines = File.ReadAllLines(args[0]);\n\tstring outputPath = args[1];\n\tif (Directory.Exists(outputPath))\n\t\toutputPath = Path.Combine(outputPath, Path.GetFileName(args[0]));\n\t{{\n\t//Convert file}}\n\tvar escapedLines = inputLines.Select(s => s.Replace(@\"\", @\"\\\"));\n\tvar outputText = string.Join(\"\\n\", escapedLines);\n\tFile.WriteAllText(outputPath, outputText);\n\tConsole.WriteLine(\"{0} characters\", outputText.Length);\n}","bugs":{"//Convert":{"type":"methods","replace":"ConvertFile(inputLines, outputPath);\n}\n\nvoid ConvertFile(IEnumerable<string> inputLines, string outputPath) {","description":"Вместо комментария, разделяющего код на две фазы, стоит сделать настоящее разделение кода на методы.\nКаждый метод должен делать ровно одну вещь.\n"}}},{"name":"CommentExplainCode","code":"{{//Check to see if the employee is eligible for full benefits\nif (employee.IsHourly() && employee.Age > 65)}} {\n\tAddBadge(employee, Badges.GreatAge);\n\tPay(employee, fullBenefitsAmount); {{//Pay largeAmount}}\n}\nelse\n\tPay(employee, reducedAmount);","bugs":{"//Check":{"type":"comments","replace":"\nif (employee.IsEligibleForFullBenefits())","description":"Вместо объясняющего комментария всегда лучше делать сам код понятнее."},"//Pay":{"type":"comments","replace":"","description":"Комментарии повторяющие код не нужны. Они легко могут устареть!"}}},{"name":"endComments","code":"void Main(string[] args) {\n\ttry {\n\t\tvar lineCount = 0;\n\t\tvar charCount = 0;\n\t\tvar lines = File.ReadAllLines(args[0]);\n\t\tforeach(var line in lines) {\n\t\t\tlineCount++;\n\t\t\tcharCount += line.Length;\n\t\t} {{//foreach}}\n\t\tConsole.WriteLine(\"lineCount = \" + lineCount);\n\t\tConsole.WriteLine(\"charCount = \" + charCount);\n\t} {{//try}}\n\tcatch (Exception e) {\n\t\tConsole.WriteLine(\"Error:\" + e.Message);\n\t} {{//catch}}\n}","bugs":{"//foreach":{"type":"comments","replace":"","description":"Комментарии вида 'конец цикла', 'конец функции' и подобные бессмысленны. "},"//try":{"type":"comments","replace":"","description":"Для коротких функций такие комментарии не нужны, а длинные функции лучше разбить на несколько более коротких."},"//catch":{"type":"comments","replace":"","description":"Современные среды разработки и программистские редакторы умеют подсвечивать парные скобки. Это надежнее таких комментариев."}}},{"name":"nameInsteadOfComment","code":"//format matched: hh:mm:ss, MMM dd, yyyy\nprivate Regex timeRegex = new Regex(@\"\\d*:\\d*:\\d*, \\w* \\d*, \\d*\");\n\nResponder {{GetResponder(); //Returns the Responder being tested.}}","bugs":{"GetResponder();":{"type":"naming","replace":"GetTestResponder();","description":"Если появляется желание написать поясняющий комментарий к методу, стоит вместо этого постараться придумать более удачное имя методу."}}},{"name":"ExplainCompare","code":"{{//comparison of this and other object}}\npublic int CompareTo(object o) {\n\tvar other = o as WikiPagePath;\n\tif(other != null) {\n\t\t{{//compares concatenated names of this and others}}\n\t\tstring thisNames = string.Join(\"\", this.Names);\n\t\tstring otherNames = string.Join(\"\", other.Names);\n\t\treturn thisNames.CompareTo(otherNames);\n\t}\n\treturn 1; // WikiPagePath should be greater than any other wrong type.\n} {{//end of CompareTo}}","bugs":{"//compares":{"type":"comments","replace":"","description":"Комментарии дословно повторяющие код бессмысленны."},"//comparison":{"type":"comments","replace":"","description":"Бессмысленно писать в комментарии то, что итак понятно из названия метода."},"//end":{"type":"comments","replace":"","description":"Комментарии вида 'конец цикла', 'конец функции' и подобные бессмысленны. \nДля коротких функций они не нужны, а длинные функции лучше разбить на несколько более коротких, вместо написания таких комментариев."}}},{"name":"XMLDoc","code":"{{/*Changes (from 11-Oct-2011)\n* --------------------------\n* 12-Sep-2011 : Fix bug\n* 11-Oct-2011 : Move implementation to another file\n* 05-Nov-2011 : Add XML comments \n*/\n}}namespace Logger{\n\t///<summary>Implement Logger to provide customized event filtering</summary>\n\t///<remarks>\n\t///<para>\n\t///Users should implement this interface to implement customized logging\n\t///event filtering. Note that <see cref=\"Logger.Repository.Hierarchy.Logger\"/>\n\t///and <see cref=\"Logger.Appender.AppenderSkeleton\"/>, the parent class of all\n\t///standard appenders, have built-in filtering rules. It is suggested that you\n\t///first use and understand the built-in rules before rushing to write\n\t///your own custom filters.\n\t///</para>\n\t///</remarks>\n\tpublic interface IFilter : IOptionHandler {\n\t\t{{///<summary>Make a decision about logging event.</summary>\n\t\t///<param name=\"loggingEvent\">The LoggingEvent to decide upon</param>\n\t\t///<returns>The decision of the filter</returns>}}\n\t\tFilterDecision Decide(LoggingEvent loggingEvent);\n\n\t\t{{///<summary>Property to get and set the next filter</summary>\n\t\t///<value>The next filter in chain</value>\n\t\t}}IFilter NextInChain { get; set; }\n\t}\n}","bugs":{"///<summary>Make":{"type":"comments","replace":"","description":"XML-комментарии не несущие новой информации бесполезны."},"///<summary>Property":{"type":"comments","replace":"","description":"Не пишите XML-комментарий только для того, чтобы он был. В наличии комментария должен быть какой-то смысл."},"/*Changes":{"type":"comments","replace":"","description":"Когда-то очень давно был смысл писать комментарии с историей изменения файла.\nНо сейчас вместо таких комментариев лучше использовать систему контроля версий и писать понятные сообщения к коммитам."}}},{"name":"collision","code":"void {{CollisionHandler}}(GameObject hero, GameObject enemy) {\n\t{{//If hero and enemy collided\n\tif ((hero.X-enemy.X)*(hero.X-enemy.X) + (hero.Y-enemy.Y)*(hero.Y-enemy.Y) \n\t\t< (hero.Radius + enemy.Radius)*(hero.Radius + enemy.Radius))}} {\n\t\thero.Life--;\n\t\tif (!hero.IsAlive) {{//no more life}}\n\t\t\tHandleHeroDeath(hero);\n\t}\n}","bugs":{"CollisionHandler":{"type":"naming","replace":"HandleCollision","description":"Методы — это действия, называйте их глаголами или глагольными фразами."},"//If":{"type":"comments","replace":"if (Collided(hero, enemy))","description":"Не используйте комментарии там, где можно выделить метод с говорящим именем."},"//no":{"type":"comments","replace":"","description":"Комментарии дословно повторяющие код бессмысленны."}}},{"name":"LoadMap","code":"///<param name=\"path\">\n/// Path to file or directory with map description. \n/// If path is a path to directory, file default.map is used.\n///</param>\nGameMap LoadMap(string path) {\n\tvar filename = Directory.Exists(path) \n\t\t? Path.Combine(path, \"default.map\") \n\t\t: path;\n\tvar lines = File.ReadAllLines(filename);\n\tvar height = lines.Length;\n\tvar width = lines[0].Length;\n\tvar map = new GameMap(width, height);\n\tfor(var y=0; y<lines.Length; y++)\n\t\tfor(var x=0; x<lines[0].Length; x++) {\n\t\t\t{{//============Select object to put in (x, y) cell;\n\t\t\tGameObject obj = null;\n\t\t\tswitch (lines[y][x]) {\n\t\t\t\tcase 'H': \n\t\t\t\t\tobj = new Hero();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tobj = new Wall();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tobj = new Monster();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//============Put created object on map}}\n\t\t\tmap.Put(x, y, obj);\n\t\t}\n\t{{//================Initialize map\n\tmap.Score = 0;\n\tmap.HeroLifesCount = 3;\n\tmap.Time = 0;}}\n\treturn map;\n}","bugs":{"//============Select":{"type":"comments","replace":"var obj = CreateGameObjectFromChar(lines[y][x]);","description":"Разделительные комментарии вроде такого часто показывают, что программист поленился выделить вспомогательный метод."},"//================Initialize":{"type":"comments","replace":"","description":"При виде комментария, разделяющего метод на смысловые части, стоит вынести эти смысловые части в отдельные методы.\nА в данном случае, инициализацию карты можно перенести в конструктор класса GameMap."}}}]);